# 2018-12-02
'''
今天看了一篇微信公众号上的文章，
发现了一个关于列表remove的问题。
'''
'''
问题：通过for-in方法，遍历使用remove方法删除列表中某个元素时可能会遇到的删除不干净的问题
'''
'''
例子：
'''
x = [1, 2, 1, 2, 1, 1, 1]
for i in x:
    if i == 1:
        x.remove(i)
'''
理想结果：x [2, 2]
实际结果: x [2, 2, 1]
'''
'''
原因：
    1. remove方法删除的是指定元素在列表中的首次出现
    2. 在列表非尾部增加或者删除元素时，该位置后面元素会向后移动或向前移动，保证元素之间的连续，但是相应的最后元素的索引也会发生变化
    3. for-in 循环本质上是获取x的__iter__()方法，转化为迭代器，然后不断调用__next__()方法
    类似于这样:
    x_iter = x.__iter__()
    try:
        while True:
            print(x_iter.__next__())
    except StopIteration:
        pass
'''
'''
分析：
    >>注意：*所谓元素为当前索引指向的元素
    [1*, 2, 1, 2, 1, 1, 1]  索引为0，执行remove    [2, 1, 2, 1, 1, 1]
    [2, 1*, 2, 1, 1, 1]     索引为1，执行remove    [2, 2, 1, 1, 1]
    [2, 2, 1*, 1, 1]        索引为2，执行remove    [2, 2, 1, 1]
    [2, 2, 1, 1*]           索引为3，执行remove    [2, 2, 1]
    [2, 2, 1]               当前索引小于列表长度，停止遍历
    所以最终结果仍然保留了一个 1
    
    >>注意：一下所说的索引皆为x_iter中的索引
    x = [1,2,3,4,5]
    x_iter = x.__iter__()          初始索引为：0

    print(x_iter.__next__())    打印结果：1       执行完后索引为：1    对应元素为：2
    print(x.remove(1))                           执行完后索引为：1    对应元素为：3     x.remove(1)后[2,3,4,5]的索引都向前推进了一位
    print(x_iter.__next__())    打印结果：3       执行完后索引为：2    对应元素为：4
    print(list(x_iter))         打印结果：[4,5]
    print(x)                    打印结果：[2,3,4,5]
'''
'''
个人看法：
    为了避免出现上述问题，在我目前所学的情况下，我认为可以采用这种方法来解决这个问题。
    x = [1, 2, 1, 2, 1, 1, 1]
    x = list(filter(lambda s: False if s==1 else True, x))
'''
